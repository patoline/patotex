{
open Dyp
open Lexing

(* When we get a real syntax error, we report the position of the parser
and the guessed reason. *)
exception Syntax_Error of Lexing.position * LatexSyntax.syntax_error

(* List of reserved keywords, only for documentation purposes since this
variable is unused in the rest of the code. *)
let reserved = [ "begin"; "end"; "documentclass"; "input" ]

(* Document class heading *)
type classoptions =
  | Bool of string
  | Val of string * string

type documentclass =
  { name : string; options : classoptions list }

(* Node type for macro calls, parameterized by the type of its
arguments. In math context, we use "math_content macro_call", while in
non-math context, we use "content macro_call".

Macro names ending with a "*" cannot be mapped to OCaml function names,
and most of them (if not all) are only a slight variation on the
non-starred macro. We thus handle them using the "is_starred" boolean.

The field "mac_name" gets the name of the macro, relative to the current
format's module in non-math context, or to the "Math" submodule of the
format in math context (this is enforced by Generateur).
*)
type 'a macro_call =
  {
    mac_name : string;
    optarg : 'a option;
    args : 'a list;
    is_starred : bool
  }

(* Document non-math content *)
and content =
  | Environment of string * content list
  | Macro of content macro_call
  | Paragraph of content list
  | Text of string
  | Math of math_content list
  | Tikz of tikz list

and tikz_coord =
  | Cart of float * float
  | Named of string
  | Polar of float * float (* angle, distance *)
  | Barycentric of (string * float) list

and tikz_move =
  | Abs of tikz_coord
  | Rel of tikz_coord
  | Rel_move of tikz_coord

and tikz_node =
  { node_name : string; node_pos : tikz_coord; node_text : content list }

and tikz_path =
  | Move_to of tikz_move
  | Line_to of tikz_move
  | Node of tikz_node

and tikz =
  | Path of tikz_path list

(* Math trees *)
and symbol=
    SimpleSym of string
  | CamlSym of string

and math_content =
     Var of string
   | Symbol of symbol
   | Fun of string
   | Num of string
   | Prefix of int * symbol * bool * math_content
   | Operator of string * math_content
   | Limits_operator of string * math_content
   | Postfix of int * math_content * bool * symbol
   | Binary of int * math_content * bool * symbol * bool * math_content
   | Indices of indices * math_content
   | Apply of math_content * math_content
   | MathMacro of math_content list macro_call
   | Delim of string * math_content * string
   | MScope of math_content list
   | MathString of string
(* Sub- and superscripts for math contents *)
and indices = {
    up_right : math_content option;
    down_right : math_content option;
    up_left : math_content option;
    down_left : math_content option }

(* Main type returned by the "main" rule of the parser *)
type document = documentclass * content

(* We definitely want to keep all parse trees generated by dypgen, at
least for debugging purposes for the moment. *)
let dypgen_choose_token = `all
let dyp_merge = keep_all

(* Paragraphs in the source text are separated by at least one blank
line, but we must also care for comments which eat the end of line
character. In particular a blank line after a comment does not count as
a paragraph separator.

We implement this behaviour by counting the number of line skips between
a possible end of a paragraph and the beginning of the next one.

The set_newline function is overriden to prevent it from counting
comments in the dyp record's positions. *)
let line_diff dyp a b =
  let a = dyp.rhs_end_pos a in
  let b = dyp.rhs_start_pos b in
  b.pos_lnum - a.pos_lnum

(* Returns true when the matched non-terminals "a" and "b" are separated
by at least one blank line. Used to track paragraph ends. *)
let layout_parskip dyp a b =
  line_diff dyp a b > 1

(* True when two text contents should belong to the same paragraph. *)
let layout_lineskip dyp a b =
  line_diff dyp a b <= 1

let set_newline ?(comment=false) buf =
  if not comment then Dyp.set_newline buf
}

%start main

%layout [' ' '\t' '\r']
%layout '\n' { set_newline lexbuf }
%layout '%' [^'\n']* '\n' { set_newline ~comment:true lexbuf }
%constructor Obj_block_contents %for block_contents block_contents_eof

%lexer

let utf8_char =
  ['\033' '\037'-'\039' '\042'-'\044' '\046'-'\060' '\062'-'\090' '\096'-'\122' '\124''\127']
  | ['\194'-'\223']['\128'-'\191']
  | ['\224'-'\238']['\128'-'\191']['\128'-'\191']
  | '\239'['\128'-'\159']['\128'-'\191']
  | ['\240'-'\243']['\128'-'\191']['\128'-'\191']['\129'-'\191']
  | '\244'['\128'-'\143']['\128'-'\191']['\128'-'\191']

let space = [' ' '\t' '\r']

let string = '"' ([^'"'] | "\\\"")* '"'
let num = ['0'-'9']+('.'['0'-'9']+)?

let ident = ['a'-'z''A'-'Z'] ['a'-'z''A'-'Z''0'-'9']*

let sword = '(' | ')' | '[' | ']' | '"' | "=" | '-'

let filename = ['a'-'z''A'-'Z'] ['_''a'-'z''A'-'Z''0'-'9']*

let word = utf8_char+

let line = (utf8_char | space)+

let comment = '%' [^'\n']* '\n'

let not_special = [^'\\' '%' '$' '{' '}' '[' ']' '\n']

main lexer =
  '{' -> BEGINGROUP
  '}' -> ENDGROUP
  '[' -> LBRACKET
  ']' -> RBRACKET
  '$' -> INLINE_MATH
  '\\' "documentclass" -> DOCUMENTCLASS
  '\\' "begin" -> BEGIN
  '\\' "end" -> END
  '\\' "input" -> INPUT
  '\\' ident -> MACRO { let l = Dyp.lexeme lexbuf in String.sub l 1 (String.length l - 1) }
  '\\' '&' -> ESCAMP
  '\\' '\\' -> BREAKLINE
  '\\' '[' -> START_DISPLAY_MATH
  '\\' ']' -> END_DISPLAY_MATH
  '\\' '{' -> LBRACE
  '\\' '}' -> RBRACE
  '\\' ' ' -> SPACE
  not_special+ -> TEXT_LINE { Dyp.lexeme lexbuf }

%parser

arg:
  BEGINGROUP [^'}']* ENDGROUP { Text $2 }
optarg:
  LBRACKET [^']']* RBRACKET { Text $2 }

math_arg:
  BEGINGROUP math ENDGROUP { $2 }
math_optarg:
  LBRACKET math RBRACKET { $2 }

block_contents_eof:
  block_contents eof { $1 }
block_contents:
  | block_of_text
  | block_contents_without_text

block_contents_without_text:
  | input<inp> [block_contents?]<bc>
    @{ (match bc with None -> inp | Some bc -> inp @ bc) , [Dyp.Dont_shift] }
  | block_without_text<bwt> [block_contents?]<bc>
    { match bc with None -> [ bwt ] | Some bc -> bwt :: bc }

block_without_text:
  block_macro | environnement

block_of_text:
  block_of_only_text<bt> block_contents_without_text?
    { match $2 with
      None -> bt
      | Some bc -> bt @ bc }

block_of_only_text:
  | paragraph<para> { [ para ] }
  | paragraph<para> block_of_only_text<bt> {
      if layout_parskip dyp 1 2
      then para::bt
      else raise Dyp.Giveup
    }

paragraph:
  text_lines<tl> { Paragraph tl }

text_lines:
  | inline_content { [ $1 ] }
  | inline_content<hd> text_lines<tl> {
      if layout_lineskip dyp 1 2
      then (if line_diff dyp 1 2 = 0 then hd::tl else hd::Text(" ")::tl )
      else raise Dyp.Giveup
    }

inline_content:
  TEXT_LINE { Text $1 }
  | SPACE { Text " " }
  | inline_math
  | macro<mac>
    { if not (List.mem mac.mac_name Thezformat.Grammar.block_content)
      then Macro mac
      else raise Dyp.Giveup }

inline_math:
  INLINE_MATH math<m> INLINE_MATH { Math m }

math:
  math_macro<mac> { [ MathMacro mac ] }

block_macro:
  macro<mac>
    { if List.mem mac.mac_name Thezformat.Grammar.block_content
      then Macro mac
      else raise Dyp.Giveup }

input:
  | INPUT BEGINGROUP filename ENDGROUP {
      let filename = $3 ^ ".tex" in
      let inch = open_in filename in
      let filelexbuf = Dyp.from_channel dyp.parser_pilot inch in
      Dyp.set_fname filelexbuf filename;
      let res = lexparse dyp.parser_pilot "block_contents_eof" filelexbuf in
      close_in inch;
      match res with
      | (Obj_block_contents a, _) :: _ -> a
      | _ -> failwith "Rat√©"
    }

environnement:
  begin<begin_name> block_contents<contents> end<end_name>
    { if begin_name <> end_name || begin_name = "tikzpicture"
      then raise Dyp.Giveup
      else Environment(begin_name, contents) }
  | begin<begin_name> tikz_contents<contents> end<end_name>
    { if begin_name <> end_name && begin_name <> "tikzpicture"
      then raise Dyp.Giveup
      else Tikz(contents) }

tikz_contents:
  [ tikz_content ";" { Path $1 } ]*

tikz_content:
  "\\path" [tikz_styles?]<styl> tikz_path*<path> { path }
  | "\\draw" [tikz_styles?]<styl> tikz_path*<path> { path }
  | "\\node" tikz_nodedecl<nd> { [ Node nd ] }
  | "\\coordinate" tikz_nodedecl<nd> { [ Node nd ] (*XXX add coordinate style *) }

tikz_path:
  tikz_move<co> { Move_to co }
  | "--" tikz_move<co> { Line_to co }
  | "node" tikz_nodedecl<nd> { Node nd }

tikz_move:
  tikz_coord<coord> { Abs coord }
  | "+" tikz_coord<coord> { Rel coord }
  | "++" tikz_coord<coord> { Rel_move coord }

tikz_coord:
  "("
  [
      [ num "," num { Cart(float_of_string $1, float_of_string $3) } ]
    | [ num ":" num { Polar(float_of_string $1, float_of_string $3) } ]
    | [ ident { Named $1 } ]
    | [ "barycentric cs:"
        [ident<id> "=" num<n> { id, float_of_string n } ]
        ["," ident<id> "=" num<n> { id, float_of_string n} ]*
        {Barycentric ($2::$3)}]
  ]<coord>
  ")" { coord }

tikz_styles:
  "[" [ tikz_style ["," tikz_style]* {$1 :: $2} ]? "]" { match $2 with
None -> [] | Some l -> l }

tikz_style:
  ident ["=" ident]?

tikz_nodedecl:
  tikz_styles? "(" ident<name> ")" "at" tikz_coord<coord> BEGINGROUP
[text_lines?]<blah> ENDGROUP
    { {node_name = name;
       node_pos = coord;
       node_text = match blah with None -> [] | Some l -> l} }

macro:
  MACRO [ '*'? { $1 = "*" } ] optarg? arg* {
    { mac_name = $1;
      args = $4;
      optarg = $3;
      is_starred = $2 }
  }

math_macro:
  MACRO [ '*'? { $1 = "*" } ] math_optarg? math_arg* {
    { mac_name = $1;
      args = $4;
      optarg = $3;
      is_starred = $2 }
  }

begin:
  BEGIN BEGINGROUP ident ENDGROUP { $3 }

end:
  END BEGINGROUP ident ENDGROUP { $3 }

document:
  begin
  block_contents
  end
  { if $1 <> "document" then
    raise (Syntax_Error(dyp.symbol_start_pos (),
LatexSyntax.Begin_document($1)))
else if $3 <> "document" then raise Dyp.Giveup else $2}

option:
  | ident { Bool($1) }
  | ident '=' ident { Val($1, $2) }

documentclass:
  DOCUMENTCLASS
    [ '[' option [',' option { $2 } ]* ']' { $2 :: $3 } ]?
    BEGINGROUP ident ENDGROUP { { name = $4; options = match $2 with None -> [] | Some l -> l } }

main:
  documentclass document eof { ($1, $2) }
